<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カメラプレビュー</title>
    <!-- UI を見やすく保つために専用のCSSを読み込む -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <main class="camera-page">
        <section class="camera-panel">
            <header>
                <h1>リアルタイムカメラ</h1>
                <p>ブラウザに接続されたカメラの映像を表示します。</p>
            </header>

            <!-- video要素を使うことで、getUserMediaのストリームをそのまま表示できる -->
            <div class="video-wrapper">
                <video id="cameraFeed" autoplay playsinline></video>
                <!-- 検出結果を描画するためのcanvas要素 -->
                <!-- video要素の上に重ねて表示することで、検出結果を視覚的に表示できる -->
                <canvas id="detectionCanvas"></canvas>
            </div>

            <!-- カメラのON/OFFを制御できるようにボタンを設置 -->
            <div class="controls">
                <button id="startCameraBtn" type="button">カメラを開始</button>
                <button id="stopCameraBtn" type="button" disabled>停止</button>
                <button id="toggleDetectionBtn" type="button" disabled>物体検出を開始</button>
            </div>

            <p class="camera-note">
                カメラを開始する際にブラウザからの許可が必要です。
            </p>

            <!-- 説明文を表示するエリア -->
            <!-- バウンディングボックスをクリックした際に、その物体の説明文を表示する -->
            <div id="descriptionPanel" class="description-panel" style="display: none;">
                <div class="description-header">
                    <h2>物体の説明</h2>
                    <button id="closeDescriptionBtn" type="button" class="close-btn">×</button>
                </div>
                <div id="descriptionContent" class="description-content">
                    <p class="loading-text">説明文を生成中...</p>
                </div>
            </div>
        </section>
    </main>

    <script>
        // ブラウザのMediaDevices APIを使ってカメラを制御する
        const video = document.getElementById("cameraFeed");
        const canvas = document.getElementById("detectionCanvas");
        const ctx = canvas.getContext("2d");
        const startBtn = document.getElementById("startCameraBtn");
        const stopBtn = document.getElementById("stopCameraBtn");
        const toggleDetectionBtn = document.getElementById("toggleDetectionBtn");
        const descriptionPanel = document.getElementById("descriptionPanel");
        const descriptionContent = document.getElementById("descriptionContent");
        const closeDescriptionBtn = document.getElementById("closeDescriptionBtn");
        let mediaStream = null;
        let detectionInterval = null;
        let isDetectionActive = false;
        let currentDetections = [];  // 現在の検出結果を保存

        // canvasのサイズをvideo要素に合わせる
        // video要素のサイズが変更されたときにcanvasも同じサイズにする
        function resizeCanvas() {
            canvas.width = video.videoWidth || video.clientWidth;
            canvas.height = video.videoHeight || video.clientHeight;
        }

        async function startCamera() {
            try {
                // フロントカメラよりも高精細な映像が欲しいため後面カメラを優先
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "environment" },
                    audio: false
                });
                video.srcObject = mediaStream;
                
                // video要素のメタデータが読み込まれたらcanvasのサイズを調整
                video.addEventListener('loadedmetadata', () => {
                    resizeCanvas();
                });
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                toggleDetectionBtn.disabled = false;
            } catch (error) {
                alert("カメラの起動に失敗しました。ブラウザの設定を確認してください。");
                console.error("Camera start error:", error);
            }
        }

        function stopCamera() {
            if (!mediaStream) return;
            
            // 物体検出を停止
            if (isDetectionActive) {
                toggleDetection();
            }
            
            // 全てのトラックを停止し、カメラへのアクセスを解放
            mediaStream.getTracks().forEach(track => track.stop());
            video.srcObject = null;
            mediaStream = null;
            startBtn.disabled = false;
            stopBtn.disabled = true;
            toggleDetectionBtn.disabled = true;
            
            // canvasをクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // フレームをキャプチャしてbase64に変換し、バックエンドに送信
        // canvas要素を使ってvideo要素の現在のフレームを描画し、base64に変換
        async function captureAndDetect() {
            if (!video.videoWidth || !video.videoHeight) return;
            
            // canvasのサイズを確認
            if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                resizeCanvas();
            }
            
            // 一時的なcanvasを作成してフレームをキャプチャ
            // 検出用のcanvasとは別に、フレームキャプチャ専用のcanvasを使用
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            // video要素の現在のフレームをcanvasに描画
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // canvasの内容をbase64エンコードされた画像データに変換
            // toDataURLメソッドでPNG形式のbase64文字列を取得
            const imageData = tempCanvas.toDataURL('image/png');
            
            try {
                // バックエンドに画像データを送信
                // POSTリクエストでJSON形式で画像データを送信
                // 信頼度閾値を0.35に設定（デフォルトの0.25より高くして精度を向上）
                // モデルサイズは's' (small)を使用（精度と速度のバランスが良い）
                const response = await fetch('/detect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        image: imageData,
                        conf_threshold: 0.35,  // 信頼度閾値（0.35以上のみ検出）
                        min_score: 0.35,  // 最小信頼度スコア（0.35以上のみ返す）
                        model_size: 's'  // 's' (small)モデルを使用（精度と速度のバランスが良い）
                    })
                });
                
                if (!response.ok) {
                    throw new Error('物体検出に失敗しました');
                }
                
                // 検出結果を取得
                const data = await response.json();
                
                // 検出結果をcanvasに描画
                drawDetections(data.detections);
                
            } catch (error) {
                console.error('Detection error:', error);
            }
        }

        // 検出結果をcanvasに描画
        // バウンディングボックスとラベルを描画して、検出された物体を視覚的に表示
        function drawDetections(detections) {
            // 前の描画をクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 検出結果を保存（クリック検出に使用）
            currentDetections = detections || [];
            
            if (!detections || detections.length === 0) return;
            
            // 各検出結果を描画
            detections.forEach((detection, index) => {
                const [x1, y1, x2, y2] = detection.box;
                const score = detection.score;
                const className = detection.class_name;
                
                // バウンディングボックスを描画
                // 検出された物体の位置を視覚的に示すために矩形を描画
                ctx.strokeStyle = '#00ff00';  // 緑色の線
                ctx.lineWidth = 3;
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                
                // ラベル背景を描画
                // テキストの可読性を高めるために背景を描画
                const label = `${className} ${(score * 100).toFixed(1)}%`;
                ctx.font = '16px Arial';
                const textMetrics = ctx.measureText(label);
                const textWidth = textMetrics.width;
                const textHeight = 20;
                
                ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.fillRect(x1, y1 - textHeight, textWidth + 10, textHeight);
                
                // ラベルテキストを描画
                // 検出された物体のクラス名と信頼度を表示
                ctx.fillStyle = '#000';
                ctx.fillText(label, x1 + 5, y1 - 5);
            });
        }

        // クリックされた位置がどのバウンディングボックス内にあるかを判定
        // canvas上のクリック位置から、対応する検出結果を特定する
        function getDetectionAtPoint(x, y) {
            // canvasの座標を取得するために、canvas要素の位置を考慮
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            // クリック位置をcanvas座標系に変換
            const canvasX = (x - rect.left) * scaleX;
            const canvasY = (y - rect.top) * scaleY;
            
            // 各検出結果のバウンディングボックス内にクリック位置があるか確認
            for (let i = currentDetections.length - 1; i >= 0; i--) {
                const detection = currentDetections[i];
                const [x1, y1, x2, y2] = detection.box;
                
                // クリック位置がバウンディングボックス内にあるか確認
                if (canvasX >= x1 && canvasX <= x2 && canvasY >= y1 && canvasY <= y2) {
                    return detection;
                }
            }
            return null;
        }

        // バウンディングボックスで囲まれた領域の画像を切り取る
        // video要素から該当領域を切り出してbase64に変換する
        async function cropImageFromBox(box) {
            const [x1, y1, x2, y2] = box;
            
            // 一時的なcanvasを作成してフレームをキャプチャ
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            
            // video要素の現在のフレームをcanvasに描画
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
            
            // 切り取る領域を計算（座標が範囲内であることを確認）
            const cropX = Math.max(0, Math.floor(x1));
            const cropY = Math.max(0, Math.floor(y1));
            const cropWidth = Math.min(tempCanvas.width - cropX, Math.floor(x2 - x1));
            const cropHeight = Math.min(tempCanvas.height - cropY, Math.floor(y2 - y1));
            
            // 切り取った画像を新しいcanvasに描画
            const cropCanvas = document.createElement('canvas');
            cropCanvas.width = cropWidth;
            cropCanvas.height = cropHeight;
            const cropCtx = cropCanvas.getContext('2d');
            
            // 元のcanvasから該当領域を切り取って新しいcanvasに描画
            cropCtx.drawImage(
                tempCanvas,
                cropX, cropY, cropWidth, cropHeight,
                0, 0, cropWidth, cropHeight
            );
            
            // 切り取った画像をbase64エンコード
            const imageData = cropCanvas.toDataURL('image/png');
            
            return imageData;
        }

        // ローカル説明文生成を使用して説明文を取得（APIキー不要）
        // 検出された物体のクラス名から、事前定義された説明文を取得
        async function getDescriptionFromLocal(detection) {
            try {
                // バックエンドに検出情報を送信
                const response = await fetch('/describe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        class_name: detection.class_name,
                        score: detection.score,
                        box: detection.box,
                        use_gpt: false  // ローカル説明文生成を使用
                    })
                });
                
                // レスポンスの内容を取得（エラーの場合も含む）
                const data = await response.json();
                
                if (!response.ok) {
                    // エラーレスポンスの場合、詳細なエラーメッセージを表示
                    const errorMsg = data.error || `HTTPエラー: ${response.status}`;
                    console.error('Server error:', errorMsg);
                    throw new Error(errorMsg);
                }
                
                // 説明文が含まれているか確認
                if (!data.description) {
                    throw new Error('説明文が返されませんでした');
                }
                
                return data.description;
                
            } catch (error) {
                console.error('Description error:', error);
                // ネットワークエラーの場合の詳細なメッセージ
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    throw new Error('サーバーに接続できませんでした。サーバーが起動しているか確認してください。');
                }
                throw error;
            }
        }

        // GPT-4o-miniに画像を送信して説明文を取得（オプション機能）
        // 切り取った画像とプロンプトをバックエンドに送信し、説明文を受け取る
        // 注意: この機能を使用するには、OpenAI APIキーが必要です
        async function getDescriptionFromGPT(imageData, prompt) {
            try {
                // バックエンドに画像データとプロンプトを送信
                const response = await fetch('/describe', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: imageData,
                        prompt: prompt
                    })
                });
                
                // レスポンスの内容を取得（エラーの場合も含む）
                const data = await response.json();
                
                if (!response.ok) {
                    // エラーレスポンスの場合、詳細なエラーメッセージを表示
                    const errorMsg = data.error || `HTTPエラー: ${response.status}`;
                    console.error('Server error:', errorMsg);
                    throw new Error(errorMsg);
                }
                
                // 説明文が含まれているか確認
                if (!data.description) {
                    throw new Error('説明文が返されませんでした');
                }
                
                return data.description;
                
            } catch (error) {
                console.error('Description error:', error);
                // ネットワークエラーの場合の詳細なメッセージ
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    throw new Error('サーバーに接続できませんでした。サーバーが起動しているか確認してください。');
                }
                throw error;
            }
        }

        // 説明文を表示する
        // バウンディングボックスをクリックした際に、その物体の説明文を表示する
        async function showDescription(detection) {
            // 説明文パネルを表示
            descriptionPanel.style.display = 'block';
            descriptionContent.innerHTML = '<p class="loading-text">説明文を生成中...</p>';
            
            try {
                // バウンディングボックスで囲まれた領域の画像を切り取る
                console.log('画像を切り取っています...', detection.box);
                const croppedImage = await cropImageFromBox(detection.box);
                
                // 画像データが正しく取得できたか確認
                if (!croppedImage || croppedImage.length < 100) {
                    throw new Error('画像の切り取りに失敗しました');
                }
                
                console.log('画像の切り取りが完了しました。サイズ:', croppedImage.length, '文字');
                
                // ローカル説明文生成を使用（APIキー不要）
                // クラス名から説明文を生成するため、画像データは送信しない
                console.log('ローカル説明文生成をリクエストしています...');
                const description = await getDescriptionFromLocal(detection);
                
                console.log('説明文が生成されました:', description);
                
                // 説明文を表示
                descriptionContent.innerHTML = `
                    <div class="detection-info">
                        <p><strong>検出された物体:</strong> ${detection.class_name}</p>
                        <p><strong>信頼度:</strong> ${(detection.score * 100).toFixed(1)}%</p>
                    </div>
                    <div class="description-text">
                        ${description.split('\n').map(line => line.trim() ? `<p>${line.trim()}</p>` : '').join('')}
                    </div>
                `;
                
            } catch (error) {
                // エラーが発生した場合はエラーメッセージを表示
                let errorMessage = error.message || '不明なエラーが発生しました';
                
                // エラーメッセージに応じて、より分かりやすいメッセージを表示
                if (errorMessage.includes('接続')) {
                    errorMessage = 'サーバーに接続できませんでした。サーバーが起動しているか確認してください。';
                }
                
                descriptionContent.innerHTML = `
                    <div class="error-text">
                        <p><strong>エラー:</strong> 説明文の生成に失敗しました</p>
                        <p>${errorMessage}</p>
                        <p style="margin-top: 12px; font-size: 0.9rem; color: #64748b;">
                            ブラウザのコンソール（F12キー）で詳細なエラー情報を確認できます。
                        </p>
                    </div>
                `;
                console.error('Full error:', error);
            }
        }

        // canvasのクリックイベントを処理
        // バウンディングボックスをクリックした際に、その物体の説明文を表示する
        canvas.addEventListener('click', (event) => {
            if (currentDetections.length === 0) return;
            
            // クリックされた位置の検出結果を取得
            const detection = getDetectionAtPoint(event.clientX, event.clientY);
            
            if (detection) {
                // 説明文を表示
                showDescription(detection);
            }
        });

        // 説明文パネルを閉じる
        closeDescriptionBtn.addEventListener('click', () => {
            descriptionPanel.style.display = 'none';
        });

        // 物体検出のON/OFFを切り替え
        // 定期的にフレームをキャプチャして物体検出を実行するかどうかを制御
        function toggleDetection() {
            if (isDetectionActive) {
                // 物体検出を停止
                if (detectionInterval) {
                    clearInterval(detectionInterval);
                    detectionInterval = null;
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                toggleDetectionBtn.textContent = '物体検出を開始';
                isDetectionActive = false;
            } else {
                // 物体検出を開始
                // 500msごとにフレームをキャプチャして物体検出を実行
                // 頻度を上げすぎるとサーバーに負荷がかかるため、適切な間隔を設定
                detectionInterval = setInterval(captureAndDetect, 500);
                toggleDetectionBtn.textContent = '物体検出を停止';
                isDetectionActive = true;
            }
        }

        startBtn.addEventListener("click", startCamera);
        stopBtn.addEventListener("click", stopCamera);
        toggleDetectionBtn.addEventListener("click", toggleDetection);
    </script>
</body>
</html>



